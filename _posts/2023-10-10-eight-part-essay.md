---
layout: post
title: "Interview Preparation"
description: "本科时期准备的面试复习资料"
categories: [technology]
tags: [computer science, interview]
redirect_from:
  - /2023/10/10/
---

# 计算机网络

- 体系结构

  1. 应用层：通过应用进程间交互来完成特定网络应用。

  - 协议：定义应用进程间通信和交互的规则。如DNS、HTTP、SMTP、FTP等。

  - 交互数据单元：报文。

  - http请求和响应的结构：

    - 请求、首部、空行、主体
    - 状态、首部、空行、实体

  2. 传输层：负责向两台主机进程间通信提供通用数据传输服务。

    - 协议：TCP、UDP
    - 区别
        - TCP：面向连接、点对点、提供全双工通信、可靠传输、流量控制、拥塞控制、面向字节流
        - UDP：无连接、可多对多、 面向报文、首部开销小

        |              | TCP                | UDP              |
        | ------------ | ------------------ | ---------------- |
        | 是否面向连接 | 是                 | 否               |
        | 是否可靠     | 是                 | 否               |
        | 传输方式     | 字节流             | 报文             |
        | 传输效率     | 低                 | 高               |
        | 所需资源     | 多                 | 少               |
        | 应用场景     | 文件传输、邮件传输 | 视频、音频、游戏 |
        | 首部开销     | 20-60字节          | 8字节            |

    - 复用：多个应用层进程同时使用下面传输层的服务
    - 分用：传输层信息交付给应用层多个进程
    - 端口在传输层添加

  3. 网络层：选择合适的网间路由和交换节点，分装数据为分组或包。

    - 协议：IP、ICMP、ARP、RARP

  4. 数据链路层：将网络数据包封装成帧，在物理介质上传输帧。每一帧包括数据和必要的控制信息。

    - 协议：OPSF路由选择协议


   5. 物理层：实现相邻节点间比特流的透明传送。尽可能屏蔽具体传输介质和物理设备差距。

- TCP

    1. 三次握手

        - 客户端-SYN包->服务端
        - 服务端-SYN+ACK包->客户端
        - 客户端-ACK包->服务端

        - 目的：建立可靠通信信道，确认双方发送和接受是正常的。

    2. 四次挥手

        - 客户端-FIN包->服务端
        - 服务端-ACK包->客户端
        - 服务端-FIN包->客户端
        - 客户端-ACK包->服务端

        - 目的：发送FIN包的一方进入半关闭状态，不再发送数据，但是可以接受数据。

    3. TCP如何保证可靠传输

        - 校验和：发送方计算校验和，接收方校验和，不一致则丢弃。
        - 序列号：保证数据包按序到达。
        - 确认应答：接收方发送ACK包，发送方超时未收到则重传。
        - 超时重传：发送方超时未收到ACK包则重传。
        - 流量控制：接收方发送窗口大小，发送方根据窗口大小发送数据。
        - 拥塞控制：慢启动、拥塞避免、快速重传、快速恢复。
        - 选择重传：接收方缓存已经收到的数据，发送方重传丢失的数据。
        - 停止等待协议：发送方发送数据后等待ACK包，接收方收到数据后发送ACK包。

    4. 停止等待协议：发送一个分组后停止发送，等待对方确认后再发送下一个分组。若收到重复分组，则丢弃，同时确认已收到。

        - 出现差错：超时重传
        - 确认丢失：接收方丢弃重复收到的消息
        - 确认迟到：发送方丢弃重复的确认，接收丢弃重复的消息
        - 自动重传ARQ：发送完一个分组需要设置一个超时计数器，简单、信道利用率低
        - 连续ARQ：发送方维持一个发送窗口，发送窗口内可以连续发送，信道利用率高，不能向发送方反应已接收到的所有分组。

    5. 滑动窗口协议：滑动窗口大小代表接收方接受缓冲区的大小。当滑动窗口为0时，只有紧急数据和1字节的通知数据，通知接收方重新声明希望接受的下一字节和发送方的滑动窗口大小。

    6. 拥塞控制：拥塞窗口（cwnd），取决于网络拥塞程度，且动态变化，发送方让自己的发送窗口取拥塞窗口和接收方较小的一个。

        - 拥塞算法：慢启动、拥塞避免、快速重传、快速恢复
        - 慢启动：cwnd从1开始，每经过一个RTT，cwnd加倍。
        - 拥塞避免：cwnd达到慢启动门限ssthresh后，每经过一个RTT，cwnd加1。
        - 快速重传和快速恢复：如果接收方接受到一个非顺序数据段，会发给发送方一个重复确认，如果发送方收到三个确认，会立即重传，这样就不会重传时要求暂停了，但是多包丢失，工作效率低。

- 浏览器访问过程

    DNS解析->TCP连接->发送HTTP请求->服务器处理请求并返回HTTP报文->浏览器解析渲染页面->连接结束

- HTTP

    1. 典型状态码

        - 200：请求成功
        - 202：请求已接受
        - 301：永久重定向
        - 302：临时重定向
        - 304：缓存
        - 400：请求错误
        - 401：未授权
        - 402：需要付费
        - 403：禁止访问
        - 404：未找到
        - 500：服务器错误
        - 502：无效网关
        - 503：服务器不可用
        - 504：网关超时

    2. HTTP与其他协议的关系

        - HTTP: 生成请求报文，解析响应报文
        - TCP: 报文分段、报文重组
        - IP: 路由选择，寻址
        - DNS: 域名解析

    3. http长连接：在一个TCP连接上可以传输多个HTTP请求和响应，减少建立和关闭连接的开销。

    4. http和https的区别

        - https需要CA证书，http不需要
        - https默认端口443，http默认端口80
        - https是安全的，http是不安全的
        - https是加密的，http是明文的
        - https需要握手，http不需要
        - https传输速度慢，http快

- IP

    1. IP地址分类

        - A类: 以0开头，1字节网络号，2^(8-1)-2个网络号，3字节主机号，容纳主机数2^24-2，从1.0.0.0到126.0.0.0。保留地址：0000和127
        - B类: 以10开头，2字节网络号，2^(16-2)-1，2字节主机号, 容纳主机数2^16-2，从128.0.0.0到191.255.0.0，最多可容纳2^16-2=65534个主机。保留地址：128
        - C类: 以110开头，3字节网络号，2^(24-3)-1, 1字节主机号，容纳主机数2^8-2从192.0.0.0到223.255.255.0，最多可容纳2^8-2=254个主机。保留地址：192
        - D类: 以1110开头，从224.0.0.0到239.255.255.255，用于多播。
        - E类: 以1111开头，从240.0.0.0到255.255.255.255, 用于研究。

    2. 子网和掩码计算10.110.12.29 mask 255.255.255.224

        子网掩码是255.255.255.11100000, 所以子网是第四个字节的前三位，10.110.12.29是10.110.12.00011101，所以子网号是000，同一子网下的IP地址前三位相同，所以同一子网下的IP地址是10.110.12.00000001到10.110.12.00011110，所以主机数是2^5-2=30。

- iptables

    - 四表

        - filter: 过滤表，用于过滤数据包，决定是否放行。包括INPUT、FORWARD、OUTPUT三个链。
        - nat: 网络地址转换表，用于网络地址转换。包括PREROUTING、POSTROUTING、OUTPUT三个链。
        - mangle: 数据包修改表，用于修改数据包。包括PREROUTING、INPUT、FORWARD、OUTPUT、POSTROUTING五个链。
        - raw: 原始数据包表，用于配置豁免某些数据包。包括PREROUTING、OUTPUT两个链。

    - 五链

        - PREROUTING: 数据包进入路由前
        - INPUT: 数据包进入本地后
        - FORWARD: 数据包转发时
        - OUTPUT: 数据包从本地发出时
        - POSTROUTING: 数据包离开路由后

- 加密

    1. 对称加密：加密和解密使用相同的密钥，速度快，但是密钥传输不安全。如：AES、DES、3DES、SEED
    2. 非对称加密：加密和解密使用不同的密钥，速度慢，但是密钥传输安全。如：RSA、DSA、ECC
    3. https：使用非对称加密传输对称加密的密钥，然后使用对称加密传输数据。
    4. aes加密：明文+key+aes加密函数 = 密文 -> 网络传输 -> 密文+key+aes解密函数 = 明文

- 网络安全

    1. 网络攻击：
        - XSS: 跨站脚本攻击，通过注入恶意脚本，获取用户信息。
        - CSRF: 跨站请求伪造，通过伪造用户请求，获取用户信息。
        - SQL注入: 通过注入SQL语句，获取数据库信息。
        - DDOS: 分布式拒绝服务攻击，通过大量请求，使服务器瘫痪。
        - DNS劫持: 通过劫持DNS服务器，获取用户信息。

    2. Cookie和Session

        - Cookie: 保存在客户端，可以设置过期时间，可以被篡改，可以被禁用。保存字符串。
        - Session: 保存在服务器，不可以设置过期时间，不可以被篡改，不可以被禁用。不区分路径，占用服务器资源，保存对象。

    3. 重定向原理：浏览器发送请求，服务器返回302状态码和Location头部，浏览器再次发送请求。

    4. IP地址hash算法：将IP地址转换为整数，然后对服务器数量取余，得到服务器索引。

# 数据结构与算法

- 数组和链表

    1. 数组：连续的内存空间，支持随机访问，插入和删除需要移动元素，时间复杂度O(n)。从栈分配空间。
    2. 链表：不连续的内存空间，不支持随机访问，插入和删除不需要移动元素，时间复杂度O(1)。从分配空间。
    3. 链表的主要作用：实现数据元素按顺序存储，管理长度和数量不固定的数据，实现树和图等数据结构。

- 排序

    | 排序算法 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
    | :------: | :------------: | :------------: | :------------: | :--------: | :----: |
    | 冒泡排序 |     O(n^2)     |      O(n)      |     O(n^2)     |    O(1)    |  稳定  |
    | 选择排序 |     O(n^2)     |     O(n^2)     |     O(n^2)     |    O(1)    | 不稳定 |
    | 插入排序 |     O(n^2)     |      O(n)      |     O(n^2)     |    O(1)    |  稳定  |
    | 快速排序 |    O(nlogn)    |    O(nlogn)    |     O(n^2)     |  O(logn)   | 不稳定 |
    |  堆排序  |    O(nlogn)    |    O(nlogn)    |    O(nlogn)    |    O(1)    | 不稳定 |
    | 归并排序 |    O(nlogn)    |    O(nlogn)    |    O(nlogn)    |    O(n)    |  稳定  |
    | 希尔排序 |   O(n^(1.3))   |                |                |    O(1)    | 不稳定 |

    1. 插入排序：将数组分为已排序区间和未排序区间，每次从未排序区间取出一个元素，插入到已排序区间的合适位置。
    2. 选择排序：将数组分为已排序区间和未排序区间，每次从未排序区间取出一个元素，插入到已排序区间的末尾。
    3. 冒泡排序：比较相邻的元素，如果前一个比后一个大，就交换位置。
    4. 快速排序：选择一个基准元素，将数组分为小于基准元素的区间和大于基准元素的区间，然后递归排序。
    5. 堆排序：将数组构建成大顶堆，然后将堆顶元素与最后一个元素交换，然后重新构建大顶堆，重复这个过程。


- hash

  - 实现：数组和链表或者红黑树，通过hash函数将key映射到数组的下标，值存储在数组中。

  - 扩容：1.创建更大的数组，2.重新计算hash值，3.将数据拷贝到新数组中。

  - hash冲突解决方法：开放定址、再hash、链地址、建立公共溢出区

- 链表、栈、队列、堆

    1. 队列: 先进先出，入队和出队时间复杂度O(1)。
    2. 栈: 先进后出，入栈和出栈时间复杂度O(1)。由编译器分配释放，采用一级缓存。
    3. 堆：完全二叉树，分为大顶堆和小顶堆，堆顶元素是最大或最小值，插入和删除时间复杂度O(logn)。多次free会导致内存泄漏。由程序员分配释放，采用二级缓存。

- 数据序列化：将结构体等复杂数据结构的各个属性有序保存在字符数组。作用：方便网络传输、方便协议解释、方便数据存储

- 二叉树：空集，或者由一个根节点和两个不相交的子二叉树组成。

  1. **按照节点度数分类**：
      - 满二叉树（Full Binary Tree）：每个节点要么没有子节点，要么有两个子节点。
      - 完全二叉树（Complete Binary Tree）：除了最底层，其他层的节点都是满的，且最底层的节点都靠左排列。

  2. **按照高度分类**：
      - 平衡二叉树（Balanced Binary Tree）：任意节点的两棵子树的高度差不大于 1。
      - 完全平衡二叉树（Perfectly Balanced Binary Tree）：所有叶子节点都在最底层，且除了叶子节点外，每个节点都有两个子节点。

  3. **按照节点连接方式分类**：
      - 二叉查找树（Binary Search Tree）：左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值。
      - 红黑树（Red-Black Tree）：一种自平衡的二叉查找树，通过对节点着色和旋转操作来保持平衡。

- 红黑树：是一种近似平衡的二叉查找树，能够确保任何一个节点的左右子树的高度差小于两倍。从一个节点到该节点的子孙节点所有路径包含相同数目黑节点

- B树：多路平衡查找树，每个节点最多有M个子节点，M>=2，根节点至少有两个子节点，其他节点至少有M/2个子节点。

- B+树：B树的变体，非叶子节点不保存数据，只用来索引，所有数据都保存在叶子节点，叶子节点之间通过指针连接。

- 动态规划：将一个复杂的问题分解为多个子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。

- 单例模式：保证一个类只有一个实例，并提供一个全局访问点。

    1. 优点：减少内存开销，避免资源占用，避免对资源的多重占用，设置全局访问点，严格控制客户访问。
    2. 缺点：扩展困难，不易于测试，与单一职责原则冲突。实例化对象长期未使用，系统会认为是垃圾，会被回收，这将导致对象状态丢失。

- 设计模式：参考其他日志。

# 操作系统

- 进程与线程

    1. 进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。
    2. 线程：进程的实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。抢占式调度，线程切换开销小。
    3. 协程：一种用户态的轻量级线程，协程的调度完全由用户控制。

- 进程间通信方式：管道、消息队列、信号量、共享内存、socket、stream socket.

    1. 管道：普通管道、流管道、命名管道。半双工，只能在具有公共祖先的进程间使用。命名管道可以在无关的进程间使用。
    2. 信号量：用于进程间同步，以及互斥操作。通常作为一种锁机制。
    3. 消息队列：消息的链表，存放在内核中并由消息队列标识符标识。
    4. 共享内存：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

- 进程状态：创建、就绪、运行、阻塞、终止

- 进程调度算法：先来先服务、短作业优先、高优先级优先、时间片轮转、多级反馈队列、最高响应比优先、最短剩余时间优先

- 线程同步：互斥量、信号量、条件变量、读写锁

- 死锁：互斥、请求与保持、不剥夺、环路等待。避免死锁：动态分配资源、按序申请资源、资源有序分配法、银行家算法。预防死锁：破坏请求与保持条件、破坏不剥夺条件、破坏环路等待条件。

- 分页和分段：

    段：信息的逻辑单位，用户可见。大小不固定，根据完成的功能来划分。向用户提供二维地址空间，段号和段内地址。

    页：信息的物理单位，用户透明。大小固定，由系统决定。向用户提供一维地址空间。

    分段存储管理：用户程序的地址空间分配为若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。段与段之间可以不相邻接，也不必须连续，离散分布在内存中。段表记录：段号、段长、段基址。

    分页存储管理：用户程序的地址空间分配为若干个大小固定的块，称为页，相应地，内存空间分配为若干个物理块，用户程序的任一页都可以放在内存的任一物理块中，实现了离散分配。页表记录：页号、块号。

    段页式存储管理：将用户程序的地址空间分成若干个大小不等的段，每段再分成若干个大小固定的页。内存空间分配为若干个物理块，用户程序的任一段的任一页都可以放在内存的任一物理块中。地址变换：段号、页号、页内偏移量。

- 页面置换算法：最佳置换算法、先进先出算法、时钟（最近最久未使用）算法

    - 最佳置换算法：选择在未来最长时间内不再被访问的页面予以置换。
    - 先进先出算法：选择在内存中驻留时间最长的页面予以置换。
    - 时钟算法：为每个页面设置一个访问位，每次访问页面时，将访问位置1。当需要替换页面时，查看指针指向的页面的访问位，若为1，则将其置0，指针指向下一个页面，直到找到访问位为0的页面，替换该页面。

- 中断和系统调用

    1. 中断：计算机执行过程中，出现特殊事件，cpu暂停当前执行程序，转去执行该事件。

        - 异常中断：计算机硬件故障或程序运行出错，如除0、越界、非法指令等。
        - 软中断：由程序员在程序中设置的中断。
        - 外中断：由cpu以外的事件引起，如I/O中断、时钟中断等。

    2. 中断优先级：机器错误 > 时钟 > 磁盘 > 网络设备 > 软中断

    3. 轮询方式：cpu不断地轮询各个中断源，检查是否有中断请求，若有，则根据中断类型进行相应的处理。缺点：浪费cpu资源。

    4. 进程执行级别：用户态和系统态（内核态）

    5. 系统调用：用户态进程通过系统调用进入内核态，执行完后返回用户态。会产生一个软中断。

    6. 进程级别转换的三种方式：系统调用、异常、外围设备的中断。

- 异步、同步、阻塞

    进程同步的机制：信号量、自旋锁管程、会合、分布式系统。
    异步调用获得结果的方式：轮询、回调函数。
    阻塞：进程/线程等待消息被挂起的状态。

- 操作系统功能：进程管理、内存管理、设备管理、文件管理、提供用户接口

- 程序：静态的，存储在磁盘上的，没有生命的。进程：动态概念且有并行特征，会竞争计算机系统资源，不同的进程可以包含相同的程序。

- 缓冲区溢出：计算机程序向缓冲区写入数据时，超出了缓冲区的边界，覆盖了其他内存区域的数据。危害：程序崩溃、提权、拒绝服务、跳转并执行恶意代码。

- 设备管理

    1. 磁盘调度算法：先来先服务、最短寻道时间优先、电梯算法、扫描算法、循环扫描算法。

- 内存管理：虚拟内存、内存映射文件、内存堆栈

- Linux文件类型：普通文件、目录文件、设备文件、链接文件

- 僵尸进程解决方案：杀死父进程、过继给init进程。避免产生僵尸进程：使用signal函数忽略SIGCHLD信号、使用wait函数回收子进程、fork两次。

- 软连接和硬连接

    1. 软连接：类似于windows的快捷方式，文件的引用，不占用磁盘空间，删除源文件后，软连接失效。
    2. 硬连接：文件的拷贝，占用磁盘空间，删除源文件后，硬连接仍然有效。

- 大端序和小端序

    1. 大端序：高位字节存放在低位地址，低位字节存放在高位地址。
    2. 小端序：高位字节存放在高位地址，低位字节存放在低位地址。

- 补码和反码：

    1. 补码：正数的补码是其本身，负数的补码是其反码加1。
    2. 反码：正数的反码是其本身，负数的反码是其符号位不变，其他位取反。

- 字符集：

    1. unicode：字符集，每个字符占用两个字节。
    2. utf-8：编码方式，可变长编码，英文一个字节，中文三个字节。
    3. utf-16：编码方式，定长编码，英文两个字节，中文两个字节。
    4. utf-32：编码方式，定长编码，英文四个字节，中文四个字节。
    5. gbk：编码方式，中文两个字节，英文一个字节。

# 数据库

- 数据库事务的四大特性：原子性、一致性、隔离性、持久性

    1. 原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
    2. 一致性：事务执行前后，数据保持一致。
    3. 隔离性：事务之间互不影响。
    4. 持久性：事务一旦提交，对数据的修改就是永久性的。

- 隔离级别：未提交读、提交读、可重复读、可串行化

    1. 未提交读：一个事务可以读取另一个未提交事务的数据，可能导致脏读。
    2. 提交读：一个事务只能读取另一个已提交事务的数据，可以避免脏读，但是可能导致不可重复读。
    3. 可重复读：一个事务只能读取另一个已提交事务的数据，可以避免脏读和不可重复读，但是可能导致幻读。
    4. 可串行化：一个事务只能读取另一个已提交事务的数据，可以避免脏读、不可重复读和幻读，但是效率低下。

- 数据库索引：B+树，增加查询速度，但是索引自身需要占用空间，且降低了增删改的速度，因为每次增删改都需要更新索引。hash索引，链表索引。

- 主键、外键、唯一索引、普通索引

    1. 主键：唯一标识一条记录，不能为null，一个表只能有一个主键。用于保证数据完整性。
    2. 外键：表的外键是另一表的主键，用来建立两个表之间的联系，可以有多个外键。用于保证数据一致性。
    3. 唯一索引：索引列的值必须唯一，但是可以为null。一个表可以有多个唯一索引。
    4. 普通索引：提高查询速度。

- 数据库三大范式：第一范式、第二范式、第三范式  

    1. 第一范式：属性不可再分。
    2. 第二范式：属性完全依赖于主键。
    3. 第三范式：属性不依赖于其他非主键属性。

- 数据完整性：实体完整性、参照完整性、用户定义完整性

    1. 实体完整性：主键不能为空。
    2. 参照完整性：外键必须是另一表的主键。
    3. 用户定义完整性：满足业务需求。

- 数据库事务：事务是由一组SQL语句组成的逻辑处理单元，事务具有以下四个特性：原子性、一致性、隔离性、持久性。

- 视图：是从一个或多个表中导出的表，视图是虚拟的，不包含数据，只包含使用时动态检索数据的查询。视图可以简化复杂的SQL操作，可以用于保护数据，可以用于更改数据的格式和表示。但是会降低查询性能，可能存在修改限制。

- 数据库优化：减少数据访问，减少交互次数，减少数据量，减少锁竞争，减少CPU消耗，减少磁盘IO。

- 大数据优化：分库分表、读写分离、缓存、异步、索引、分区、垂直拆分、水平拆分、冷热数据分离、负载均衡、集群、分布式、云计算。

- 高并发解决方案：

    - 横向扩展：通过增加服务器数量来提高系统性能。

    - 引入缓存：将数据缓存在内存中，减少数据库的访问，提高系统性能。

    - 引入消息队列(消峰)：通过消息队列解决瞬时高并发的问题，但是如果请求量一直很高，挤压的请求会一直积压在消息队列中，会导致消息队列成为系统的瓶颈。

    - 读写分离：将读请求和写请求分开，读请求发送到从库，写请求发送到主库。

    - 分库分表：将数据分散到多个数据库中，或者将长字段分离到其他表中。

    - 优化SQL语句：优化查询语句，减少数据库的访问。

    - 优化数据库结构：降低范式，增加冗余字段，减少关联查询。

    - 单元化：将业务分成多个可扩展的逻辑分区，每个分区都是一个单元，每个单元都可以独立部署，单元之间通过消息队列通信。

    - 引入ES：对比数据库的B+树索引，ES的倒排索引更适合搜索引擎，可以提高搜索效率。这是在解决多维复杂查询的问题。

- 常用SQL语句：

    1. 创建数据库：

        ```create database <数据库名>```

    2. 删除数据库：

        ```drop database <数据库名>```

    3. 创建表：

        ```create table <表名> (<列名1> <数据类型1> <列级完整性约束1>, <列名2> <数据类型2> <列级完整性约束2>, ..., <表级完整性约束1>, <表级完整性约束2>, ...)```

    4. 删除表：

        ```drop table <表名>```

    5. 增加列：

        ```alter table <表名> add <列名> <数据类型> <列级完整性约束>```

    6. 删除列：

        ```alter table <表名> drop <列名>```

    7. 修改列：

        ```alter table <表名> modify <列名> <数据类型> <列级完整性约束>```

    8. 增加主键：

        ```alter table <表名> add primary key (<列名>)```

    9. 删除主键：

        ```alter table <表名> drop primary key```

    10. 创建索引：

        ```create index <索引名> on <表名> (<列名>)```

    11. 删除索引：

        ```drop index <索引名>```

    12. 创建视图：

        ```create view <视图名> as <select语句>```

    13. 删除视图：

        ```drop view <视图名>```

    14. 选择：

        ```select <列名1>, <列名2>, ... from <表名> where <条件> group by <列名> having <条件> order by <列名>```

    15. 插入：

        ```insert into <表名> (<列名1>, <列名2>, ...) values (<值1>, <值2>, ...)```

    16. 更新：

        ```update <表名> set <列名1> = <值1>, <列名2> = <值2>, ... where <条件>```

    17. 删除：

        ```delete from <表名> where <条件>```

    18. 事务：

        `commit transaction`、`rollback transaction`、`begin transaction`

    19. 连接：

        `left join`、`right join`、`full join`、`inner join`

    20. 子查询：

        ```select <列名1>, <列名2>, ... from <表名> where <条件> and <列名> in (select <列名> from <表名> where <条件>)```

    21. 计数：

        ```select count(*) from <表名> where <条件>```

    22. 求和：

        ```select sum(<列名>) from <表名> where <条件>```

    23. 复制表：

        ```select * into <新表名> from <旧表名> where <条件>```

    24. 删除重复行：

        ```select distinct <列名1>, <列名2>, ... from <表名> where <条件>```

    25. 分组：

        ```select <列名1>, <列名2>, ... from <表名> group by <列名>```

    26. 拷贝数据：

        ```insert into <表名> (<列名1>, <列名2>, ...) select <列名1>, <列名2>, ... from <表名> where <条件>```


# 编程语言

## Python

1. 多线程

   - GIL：全局解释器锁，Python中的一个线程对应于C语言中的一个线程，GIL使得同一时刻只有一个线程在一个CPU上执行字节码，无法将多个线程映射到多个CPU上执行。GIL会根据执行的字节码行数以及时间片释放GIL，GIL在遇到IO操作时主动释放。

   - 多线程的作用：对于IO密集型程序，多线程能够提高程序的执行效率，提高程序的响应速度。

   - 实现多线程的方式：threading模块、multiprocessing模块、concurrent.futures模块、asyncio模块。

        - threading模块：创建线程的方式，创建线程的方式有两种，一种是直接调用threading.Thread()方法，另一种是继承threading.Thread类并重写run()方法。

        - multiprocessing模块：创建进程的方式，创建进程的方式有两种，一种是直接调用multiprocessing.Process()方法，另一种是继承multiprocessing.Process类并重写run()方法。

        - futures模块：线程池和进程池，使用线程池和进程池的方式有两种，一种是直接调用concurrent.futures.ThreadPoolExecutor()方法或concurrent.futures.ProcessPoolExecutor()方法，另一种是继承concurrent.futures.ThreadPoolExecutor类或concurrent.futures.ProcessPoolExecutor类并重写run()方法。

        - asyncio模块：协程，使用协程的方式有两种，一种是直接调用asyncio.coroutine()方法，另一种是使用async关键字。

2. 常用数据结构

   - 列表：list，有序，可变，可重复，可嵌套，可切片，可迭代，可排序，可比较，可拼接，可删除，可修改，可增加，可查找，可遍历，可推导，可转换，可复制，可清空，可删除，可获取长度，可获取最大值，可获取最小值，可获取索引，可获取元素。本质是可变长度的数组。
   - 元组：tuple，有序，不可变。本质是固定长度、不可变的数组。
   - 字典：dict，无序，可变。本质是伪随机探测的哈希表。
   - 集和：set，无序，可变，不可重复。本质是空值的哈希表。

3. 拷贝

    - 直接赋值：`a = b`，a和b指向同一个对象，修改a会影响b，修改b会影响a。
    - 浅拷贝：`a = b.copy()`，a和b指向不同的对象，修改a不会影响b，修改b会影响a，但是如果a和b中的元素是可变对象，修改a中的元素会影响b中的元素，修改b中的元素会影响a中的元素。
    - 深拷贝：`a = copy.deepcopy(b)`，a和b指向不同的对象，修改a不会影响b，修改b不会影响a。
    - 数组拷贝：`a = b[:]`，浅拷贝。

4. 装饰器

    - 装饰器的作用：在不修改原函数的情况下，为原函数添加新的功能。
    - 装饰器的实现：使用闭包实现装饰器，使用functools.wraps()装饰内部函数。使用@符号将装饰器应用到函数上。
    - 装饰器的分类：无参装饰器、有参装饰器、类装饰器、装饰器链。

    - example：

        ```python
        import functools

        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                print('before')
                result = func(*args, **kwargs)
                print('after')
                return result
            return wrapper

        @decorator
        def func():
            print('func')

        func()
        ```


5. 迭代器

    - 迭代器的作用：迭代器是一个可以记住遍历位置的对象，迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器只能往前不会后退，迭代器有两个基本的方法：iter()和next()。
    - 迭代器的实现：使用yield关键字实现迭代器，使用for循环遍历迭代器。
    - example：

        ```python
        def generator():
            for i in range(10):
                yield i

        for i in generator():
            print(i)
        ```


6. 生成器

    - 生成器的作用：生成器是一种特殊的迭代器，生成器是一个函数，使用yield关键字返回一个迭代器，生成器的本质是一个迭代器。
    - 生成器的实现：使用yield关键字实现生成器，使用for循环遍历生成器。
    - example：

        ```python
        def generator():
            for i in range(10):
                yield i

        for i in generator():
            print(i)
        ```

7. 闭包

    - 闭包的作用：闭包是一个函数，它可以访问其他函数内部的变量，闭包可以将函数内部的变量保存在内存中，闭包可以避免使用全局变量。
    - 闭包的实现：使用闭包的方式有两种，一种是使用嵌套函数，另一种是使用类。
    - example：

        ```python
        def outer():
            a = 1
            def inner():
                print(a)
            return inner

        func = outer()
        func()
        ```

8. "+"问题及优化

    - "+"问题：字符串是不可变的，使用"+"拼接字符串时，每次都会创建一个新的字符串对象，然后将原字符串对象和新的字符串对象拼接，连续使用"+"拼接字符串时，会产生大量的临时字符串对象，占用大量的内存空间，影响程序的执行效率。
    - 优化：使用列表代替字符串，使用"".join()方法拼接字符串。


9. "=="和"is"的区别

    - "=="：比较两个对象的值是否相等。
    - "is"：比较两个对象的内存地址是否相等。

10. 垃圾回收机制

    - 当python的某个对象引用计数为0时，该对象就要成为被回收的对象。Del对象后，垃圾回收启动，将所占内存清空。垃圾回收时，python不进行其他任务，频繁回收，会降低工作效率。分配对象和取消分配对象差值高于阈值时，才会启动回收。

11. 内存管理方式

    - 引用计数：当一个对象被引用时，它的引用计数加1，当一个对象的引用计数为0时，它会被垃圾回收机制回收。
    - 标记清除：当一个对象被引用时，它的标记为1，当一个对象的标记为0时，它会被垃圾回收机制回收。
    - 分代回收（内存池）：将所有的对象分为三代，当一个对象被引用时，它的代数为0，当一个对象的代数为2时，它会被垃圾回收机制回收。

12. 循环引用处理：
    - 延迟导入；
    - 将`from module import package`改为`import module.package`；
    - 重新组织代码结构；
    - 使用弱引用。

13. 文件操作注意事项：打开模式、异常处理、文件对象的关闭，接收缓冲区的大小。

14. 调试方式：

    - 断点打印
    - 断言
    - 日志
    - IDE调试
    - pdb调试

15. 面向对象三大特性：封装、继承、多态。

    - 封装：将数据和方法封装到类中，数据和方法只对类的内部可见，对外部不可见。
    - 继承：子类继承父类的属性和方法。
    - 多态：同一种事物的多种形态。

16. python的语言特性：面向对象、动态类型、强类型、解释型、可扩展，代码可读性好。

17. Django vs Flask

    - Django: 自带ORM，Web管理界面等内置功能，鼓励快速开发和简洁的设计，适合快速开发，适合大型项目，适合重量级的项目。

    - Flask: 具有高度的灵活性，核心功能只包含路由分发和模板引擎，非常适合轻量级项目的开发，同时为项目组织结构提供了更大的灵活性。

18. Django的访问生命周期：

    url -> wsgi -> middleware -> router -> view -> middleware -> response -> wsgi -> url

    1. url解析
    2. wsgi将Web服务器收到的HTTP请求转发给Django应用程序.
    3. 中间件是一种机制，允许在视图处理前后执行自定义的逻辑。在这个步骤中，请求可能会经过一个或多个中间件，这些中间件可以执行诸如身份验证、日志记录等操作。
    4. Django的路由系统会根据URL将请求分发到相应的视图函数或类。
    5. 在视图阶段，请求被传递给匹配的视图函数或类，这里进行具体的请求处理逻辑，比如从数据库中获取数据、进行业务逻辑处理等。
    6. 在视图处理完成后，响应会被传递给中间件，中间件可以执行诸如日志记录、缓存等操作。
    7. 在视图函数或类处理完请求后，生成HTTP响应，包括响应的内容和状态码等。
    8. 最后，响应通过WSGI接口返回给Web服务器，然后由Web服务器发送给客户端。

19. redis作用：缓存、会话存储、消息队列、存储需要快速访问的数据。

## Go

# 其他

## 运维

1. DevOps：通过自动化、协作和持续改进，加速软件交付的速度和频率，同时提高软件质量和系统稳定性。包括：

    - 自动化软件交付：DevOps 团队负责设计、实施和维护自动化的软件交付流程，包括持续集成（CI）、持续交付（CD）以及自动化部署和测试。

    - 环境管理：DevOps 团队负责管理开发、测试和生产环境的配置和部署，确保这些环境的一致性和可靠性。

    - 运维和监控：DevOps 团队负责监控生产系统的性能和稳定性，及时发现并解决问题，确保系统的高可用性和可靠性。

    - 容器化和编排：DevOps 团队可能负责容器化应用程序，并使用容器编排工具（如 Kubernetes）来管理和调度这些容器。

    - 自动化测试：DevOps 团队负责设计和实施自动化测试策略，包括单元测试、集成测试、端到端测试等，以确保软件质量和稳定性。

    - 安全和合规性：DevOps 团队需要关注软件交付过程中的安全性和合规性，确保开发的应用程序符合相关的安全标准和法规要求。

    - 跨团队协作：DevOps 团队需要促进开发、运维和其他相关团队之间的协作和沟通，以确保整个软件交付过程的顺畅进行。

2. AI在Devops中的应用：

    - 用于自动化测试，包括自动生成测试用例、执行自动化测试脚本、分析测试结果以及识别潜在的缺陷和问题。

    - 优化 CI/CD 流程，例如通过自动化构建、测试和部署流程，以及智能化的部署策略和回滚机制。

    - 用于实时监控系统和应用程序，并自动检测和诊断问题，甚至提出修复建议或执行自动化修复操作。

    - 分析系统和应用程序的性能数据，预测潜在的故障和问题，并提前采取措施以防范故障发生，从而提高系统的稳定性和可靠性。

    - 用于自动化安全审计，识别安全漏洞和威胁，以及执行自动化的安全补丁和修复操作。

    - 用于自动化运维任务，包括自动化故障处理、自动化容量规划和资源优化，以及自动化配置管理和环境部署。

3. SRE: 一种将软件工程和运维运营原则结合起来的角色和方法论。SRE的职责是确保系统的可靠性、可用性和可扩展性，以满足用户需求。

    - 监控和警报：设置和维护监控系统，及时发现并解决系统问题。

    - 容量规划：预测系统资源需求，确保系统能够满足用户的负载。

    - 故障响应：快速诊断和解决系统故障，最小化系统的停机时间。

    - 自动化：开发和维护自动化工具和流程，提高效率和可靠性

    - 性能优化：分析和改进系统性能，提高用户体验。

    - 系统设计和架构：参与系统设计和架构决策，确保系统具备可靠性和可扩展性。

    - 紧急事件管理：制定和执行紧急事件响应计划，保障系统的稳定性。

    - 跨团队合作：与开发团队、运维团队和其他相关团队合作，共同解决问题和改进系统。

4. Devops和SRE的区别和联系

| 方面       | SRE                                              | DevOps                                        |
| ---------- | ------------------------------------------------ | --------------------------------------------- |
| 主要关注点 | 系统的可靠性、可用性和可扩展性                   | 软件开发和运维的协同和流程改进                |
| 角色定位   | 一种特定的工程角色                               | 一种文化和方法论                              |
| 历史背景   | 起源于Google，强调运维的工程化和自动化           | 起源于敏捷开发和持续交付的思想                |
| 重点       | 运维和系统稳定性                                 | 开发和运维的协同和流程改进                    |
| 目标       | 确保系统高可靠性和可用性，快速响应变化的需求     | 加强开发和运维之间的合作，提高交付速度和质量  |
| 关键实践   | 监控和警报、容量规划、故障响应、自动化、性能优化 | 持续集成/交付、自动化部署、配置管理、持续监控 |
| 团队合作   | 与开发团队、运维团队合作，共同解决问题和改进系统 | 开发团队和运维团队之间的紧密合作和沟通        |
| 度量和指标 | SLA、SLO、SLI等度量系统可靠性和可用性的指标      | 故障率、交付速度、回归测试时间等指标          |

两者都强调自动化和流程改进，以提高效率和减少人为错误。它们都鼓励开发人员和运维人员之间的合作和沟通，以实现共同的目标。

5. CPU占用过高的排错和处理流程：

    - 监控系统资源：使用系统监控工具（如top、htop、或者基于Web的监控工具）来确认CPU占用情况，并观察是否有任何异常的进程或服务占用大量CPU资源。
    - 识别高CPU消耗的进程：通过命令行工具或监控系统的界面，找出消耗大量CPU资源的进程。
    - 分析日志：查看系统日志和应用程序日志，以便发现任何相关的错误或异常信息。
    - 优化代码：如果高CPU占用是由自己开发的应用程序引起的，可以通过代码优化来降低CPU消耗，比如减少循环次数、优化算法等。
    - 增加硬件资源：如果问题是由于硬件资源不足导致的，可以考虑增加CPU核心数或者升级CPU性能。
    - 限制进程资源：对于某些进程，可以通过操作系统的工具（如cgroups）来限制其CPU使用，以避免其过度占用CPU资源。
    - 升级软件版本：有时高CPU占用可能是由于软件版本问题导致的，升级软件版本到最新稳定版可能会解决一些性能问题。
    - 故障转移：如果可能的话，可以通过负载均衡或者故障转移，将部分请求转移到其他服务器上，以减轻当前服务器的负载。
    - 横向扩展：如果单台服务器无法满足需求，可以考虑引入更多服务器，采用集群的方式来分担负载。
    - 持续监控和优化：定期进行系统性能分析，持续优化系统配置和应用程序性能，以确保服务器资源得到合理利用。
